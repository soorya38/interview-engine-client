<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interview Engine Client</title>
    <!-- Google Fonts & Material Icons -->
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    <style>
        :root {
            --meet-bg: #202124;
            --control-bar-bg: #2d2f34;
            --primary-blue: #8ab4f8;
            --hangup-red: #ea4335;
            --text-primary: #e8eaed;
            --text-secondary: #bdc1c6;
            --surface-color: #3c4043;
            --border-color: #5f6368;
            --drag-handle-bg: rgba(255, 255, 255, 0.1);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            scroll-behavior: smooth;
            touch-action: manipulation;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--meet-bg);
            color: var(--text-primary);
            min-height: 100vh; 
            overflow-x: hidden;
            display: flex;
            justify-content: center;
            position: relative;
        }

        .hidden { display: none !important; }

        /* --- LOBBY SCREEN --- */
        #lobby-screen {
            display: flex;
            width: 100%;
            max-width: 1000px;
            gap: 24px;
            padding: 40px 20px;
            align-items: stretch;
        }

        .lobby-preview {
            flex: 2;
            background-color: #35363a;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 20px;
            padding: 20px;
            min-height: 400px;
        }
        
        .lobby-avatar {
            font-size: 80px;
            background-color: #522da2;
            width: 140px;
            height: 140px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .lobby-preview h2 {
            font-weight: 500;
        }

        .lobby-setup {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .lobby-setup h1 {
            font-weight: 400;
            margin-bottom: 24px;
            text-align: center;
        }

        #join-btn {
            background-color: var(--primary-blue);
            color: #202124;
            font-weight: 500;
            font-size: 1rem;
            border-radius: 24px;
            padding: 12px 24px;
            border: none;
            cursor: pointer;
            margin-top: 20px;
        }

        /* --- MEET SCREEN --- */
        #meet-screen {
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column; 
            position: relative;
            background-color: var(--meet-bg);
        }

        .main-content {
            flex-grow: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            padding: 20px;
            padding-bottom: 100px;
            overflow: hidden; 
        }

        #interviewer-view {
            width: 100%;
            height: 100%;
            max-width: 900px;
            max-height: 700px;
            background-color: #35363a;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
            z-index: 1;
        }
        
        #interviewer-avatar {
            font-size: 60px;
            width: 100px;
            height: 100px;
            background-color: #522da2;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        #interviewer-message {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.6);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
            min-height: 50px;
            font-size: 1.2rem;
        }

        /* --- DRAGGABLE ANSWER BOX --- */
        #user-view {
            position: absolute;
            width: 320px;
            height: 220px;
            background-color: #35363a;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
            z-index: 5;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            transition: box-shadow 0.2s ease, transform 0.2s ease;
            /* Initial position */
            bottom: 110px;
            right: 20px;
        }

        #user-view.dragging {
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
            z-index: 15;
            transition: none;
        }

        #user-view.dragging .drag-handle {
            background-color: var(--primary-blue);
        }

        .drag-handle {
            background-color: var(--drag-handle-bg);
            padding: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            touch-action: none;
            z-index: 10;
            border-bottom: 1px solid var(--border-color);
            position: relative;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .drag-handle span {
            font-size: 16px;
            color: var(--text-secondary);
        }

        #user-view-label {
            padding: 8px;
            font-size: 0.9rem;
            background: rgba(0,0,0,0.3);
            flex-shrink: 0;
            user-select: none;
            -webkit-user-select: none;
        }

        #answer-input {
            flex-grow: 1;
            background: transparent;
            border: none;
            color: var(--text-primary);
            font-size: 1rem;
            padding: 10px;
            resize: none;
            outline: none;
            width: 100%;
            height: 100%;
            user-select: text !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
            cursor: text;
        }

        #answer-input:focus {
            outline: 2px solid var(--primary-blue);
            outline-offset: -2px;
        }

        #voice-command-hint {
            font-size: 0.75rem; 
            color: var(--text-secondary); 
            padding: 0 10px 4px 10px; 
            text-align: center;
            background: rgba(0,0,0,0.2);
            flex-shrink: 0;
            user-select: none;
            -webkit-user-select: none;
        }

        /* --- SILENCE DETECTION INDICATOR --- */
        .silence-indicator {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-secondary);
            transition: background 0.3s ease;
            z-index: 10;
            pointer-events: none;
        }

        .silence-indicator.speaking {
            background: var(--primary-blue);
            animation: pulse-small 1s infinite;
        }

        .silence-indicator.silent {
            background: var(--hangup-red);
        }

        @keyframes pulse-small {
            0% { box-shadow: 0 0 0 0 rgba(138, 180, 248, 0.7); }
            70% { box-shadow: 0 0 0 4px rgba(138, 180, 248, 0); }
            100% { box-shadow: 0 0 0 0 rgba(138, 180, 248, 0); }
        }

        /* Control Bar */
        #control-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 80px;
            background-color: var(--control-bar-bg);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 24px;
            z-index: 10;
        }

        .control-group { 
            display: flex; 
            gap: 12px; 
            align-items: center; 
        }

        .control-button {
            background-color: var(--surface-color);
            color: var(--text-primary);
            border: none;
            width: 56px;
            height: 40px;
            border-radius: 20px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: background-color 0.2s;
            touch-action: manipulation;
        }
        
        .control-button:hover {
            background-color: #45474a;
        }
        
        .control-button.hang-up {
            background-color: var(--hangup-red);
            width: 60px;
        }
        
        .control-button.is-recording {
            background-color: var(--hangup-red);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(234, 67, 53, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(234, 67, 53, 0); }
            100% { box-shadow: 0 0 0 0 rgba(234, 67, 53, 0); }
        }

        /* --- Side Panels (Chat & Settings) --- */
        .side-panel {
            width: 320px;
            background-color: #ffffff;
            color: #202124;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
            transform: translateX(100%);
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            z-index: 20;
        }

        #meet-screen.chat-open #chat-panel,
        #meet-screen.settings-open #settings-panel {
            transform: translateX(0);
        }
        
        .side-panel-header {
            padding: 16px 24px;
            border-bottom: 1px solid #dadce0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .close-side-panel-btn {
            background: none;
            border: none;
            cursor: pointer;
            color: #5f6368;
            padding: 4px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .close-side-panel-btn:hover {
            background-color: #f1f3f4;
        }
        
        #chat-history, #settings-content {
            flex-grow: 1;
            overflow-y: auto;
            padding: 16px;
        }
        #chat-history {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .chat-message .sender { 
            font-weight: 700; 
            margin-bottom: 4px;
        }
        
        /* --- GENERIC & REUSED STYLES --- */
        label { 
            display: block; 
            font-weight: 500; 
            margin-bottom: 5px; 
            color: var(--text-secondary); 
        }
        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            background: var(--surface-color);
            border-radius: 4px;
            color: var(--text-primary);
            margin-bottom: 15px;
        }
        
        /* Style adjustments for side panels with white background */
        .side-panel label { color: #3c4043; }
        .side-panel input, .side-panel select {
            color: #202124;
            background-color: #f1f3f4;
            border-color: #dadce0;
        }

        .tab-button {
            padding: 10px; 
            cursor: pointer; 
            border: none; 
            background: transparent; 
            color: var(--text-secondary);
            font-size: 1rem; 
            border-bottom: 2px solid transparent;
            touch-action: manipulation;
        }
        .tab-button.active { 
            color: var(--primary-blue); 
            border-bottom-color: var(--primary-blue); 
        }
        .tab-pane { padding: 16px 0; }
        
        #summary-modal {
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%;
            display: flex; 
            justify-content: center; 
            align-items: center;
            background: rgba(0, 0, 0, 0.7); 
            z-index: 30;
        }
        #summary-content { 
            background: var(--control-bar-bg); 
            padding: 30px; 
            border-radius: 8px; 
            width: 100%; 
            max-width: 500px; 
            max-height: 90vh; 
            overflow-y: auto;
        }

        /* --- RESPONSIVE STYLES --- */
        @media screen and (max-width: 900px) {
            #lobby-screen {
                flex-direction: column;
                max-width: 500px;
                padding: 20px;
            }
        }

        @media screen and (max-width: 768px) {
            .main-content { 
                padding: 10px; 
                padding-bottom: 90px; 
            }
            
            #user-view { 
                width: 280px; 
                height: 200px; 
                max-width: 90vw;
                max-height: 40vh;
            }
            
            #interviewer-message { 
                font-size: 1rem; 
                bottom: 10px; 
                left: 10px; 
                right: 10px; 
            }
            
            #control-bar { 
                height: 70px; 
                padding: 0 10px; 
                flex-wrap: nowrap; 
            }
            
            #control-bar .control-group:first-child, 
            #control-bar .control-group:last-child { 
                flex-shrink: 0; 
            }
            
            #control-bar .control-group:nth-child(2) { 
                justify-content: center; 
                flex-grow: 1; 
            }
            
            .control-group { gap: 6px; }
            .control-button { 
                width: 44px; 
                height: 38px; 
            }
            .control-button.hang-up { width: 52px; }
            
            .side-panel { width: 100%; }
            #summary-content { 
                max-width: 90vw; 
                padding: 20px; 
            }
            
            .drag-handle span {
                font-size: 14px;
            }
        }

        @media screen and (max-width: 480px) {
            #user-view { 
                width: 260px; 
                height: 180px; 
            }
            
            #control-bar .control-group:nth-child(2) {
                gap: 4px;
            }
        }

        /* Touch device optimizations */
        @media (hover: none) and (pointer: coarse) {
            .control-button:hover {
                background-color: var(--surface-color);
            }
            
            #user-view {
                touch-action: pan-y pan-x;
            }
            
            .drag-handle {
                touch-action: none;
            }
        }
    </style>
</head>
<body>

    <!-- LOBBY SCREEN -->
    <div id="lobby-screen">
        <div class="lobby-preview">
            <div class="lobby-avatar"><span class="material-symbols-outlined" style="font-size: 80px;">smart_toy</span></div>
            <h2>AI Interviewer is ready</h2>
        </div>
        <div class="lobby-setup">
            <h1>Interview Engine Client - Alpha</h1>
            <div>
                <label for="user-id">User ID</label>
                <input type="text" id="user-id" placeholder="Enter your User ID">
                <label for="topic-select">Topic</label>
                <select id="topic-select"><option>Set User ID to load topics...</option></select>
            </div>
            
            <div class="management-tabs" style="display:flex; margin-top: 15px;">
                <button class="tab-button active" data-tab="topic-panel">Topics & Questions</button>
                <button class="tab-button" data-tab="voice-panel">Voice</button>
            </div>
            <div id="topic-panel" class="tab-pane">
                 <h4 style="font-weight: 500; margin-bottom: 10px;">Create Topic</h4>
                 <input type="text" id="new-topic-input" placeholder="New topic name...">
                 <button id="create-topic-btn" style="width:100%; padding: 8px; border-radius:4px; border:none; background: var(--surface-color); color: var(--text-primary); cursor:pointer;">Create Topic</button>
                 <hr style="border-color: var(--border-color); margin: 20px 0;">
                 <h4 style="font-weight: 500; margin-bottom: 10px;">Create Question</h4>
                 <label for="question-topic-select">For Topic:</label>
                 <select id="question-topic-select"></select>
                 <textarea id="new-question-input" placeholder="New question text..." style="min-height: 80px;"></textarea>
                 <button id="create-question-btn" style="width:100%; padding: 8px; border-radius:4px; border:none; background: var(--surface-color); color: var(--text-primary); cursor:pointer;">Create Question</button>
            </div>
            <div id="voice-panel" class="tab-pane hidden">
                <label for="apiKey">Google Cloud API Key</label>
                <input type="password" id="apiKey" placeholder="Required for speech">
                <label for="voiceSelect">Interviewer Voice</label>
                <select id="voiceSelect">
                    <!-- Options are duplicated in settings panel -->
                </select>
            </div>
            
            <button id="join-btn">Join Now</button>
        </div>
    </div>

    <!-- MEET SCREEN -->
    <div id="meet-screen" class="hidden">
        <div class="main-content">
            <div id="interviewer-view">
                <div id="interviewer-avatar"><span class="material-symbols-outlined" style="font-size: 60px;">smart_toy</span></div>
                <div id="interviewer-message">Waiting to start...</div>
            </div>
            
            <div id="user-view">
                <div class="drag-handle" id="drag-handle">
                    <span class="material-symbols-outlined">drag_indicator</span>
                </div>
                <div class="silence-indicator" id="silence-indicator"></div>
                <div id="user-view-label">Your Response</div>
                <textarea id="answer-input" placeholder="Type or use the mic to reply..."></textarea>
                <div id="voice-command-hint">
                    Try: "send answer", "open chat", "end interview"
                </div>
            </div>
        </div>

        <div id="chat-panel" class="side-panel">
            <div class="side-panel-header">
                <h3>In-call messages</h3>
                <button id="close-chat-btn" class="close-side-panel-btn" title="Close">
                    <span class="material-symbols-outlined">close</span>
                </button>
            </div>
            <div id="chat-history"></div>
        </div>

        <!-- NEW SETTINGS PANEL -->
        <div id="settings-panel" class="side-panel">
            <div class="side-panel-header">
                <h3>Settings</h3>
                <button id="close-settings-btn" class="close-side-panel-btn" title="Close">
                    <span class="material-symbols-outlined">close</span>
                </button>
            </div>
            <div id="settings-content">
                <label for="apiKey-in-call">Google Cloud API Key</label>
                <input type="password" id="apiKey-in-call" placeholder="Required for speech">
                <label for="voiceSelect-in-call">Interviewer Voice</label>
                <select id="voiceSelect-in-call">
                    <!-- Options are populated by JS -->
                </select>
            </div>
        </div>

        <footer id="control-bar">
            <div class="control-group">
                <span id="current-time">12:00 PM</span>
            </div>
            <div class="control-group">
                <button id="voice-reply-btn" class="control-button" title="Reply with Voice"><span class="material-symbols-outlined">mic</span></button>
                <button id="send-answer-btn" class="control-button" title="Send Answer"><span class="material-symbols-outlined">send</span></button>
                <button id="hang-up-btn" class="control-button hang-up" title="End Interview"><span class="material-symbols-outlined">call_end</span></button>
            </div>
            <div class="control-group">
                <button id="toggle-settings-btn" class="control-button" title="Settings"><span class="material-symbols-outlined">settings</span></button>
                <button id="toggle-chat-btn" class="control-button" title="Toggle Chat"><span class="material-symbols-outlined">chat</span></button>
            </div>
        </footer>
    </div>
    
    <div id="summary-modal" class="hidden">
        <div id="summary-content">
            <h2>Interview Summary</h2>
            <div id="summary-details"></div>
            <button id="close-summary-btn" style="margin-top: 20px; border-radius:24px; padding:10px 20px; border:none; cursor:pointer;">Back to Lobby</button>
        </div>
    </div>
    
    <audio id="audioPlayer"></audio>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const lobbyScreen = document.getElementById('lobby-screen'), 
                  meetScreen = document.getElementById('meet-screen'), 
                  joinBtn = document.getElementById('join-btn'), 
                  hangUpBtn = document.getElementById('hang-up-btn'), 
                  sendAnswerBtn = document.getElementById('send-answer-btn'), 
                  toggleChatBtn = document.getElementById('toggle-chat-btn'), 
                  closeChatBtn = document.getElementById('close-chat-btn'), 
                  interviewerMessage = document.getElementById('interviewer-message'), 
                  chatHistory = document.getElementById('chat-history'), 
                  currentTimeEl = document.getElementById('current-time'), 
                  closeSummaryBtn = document.getElementById('close-summary-btn'), 
                  userIdInput = document.getElementById("user-id"),
                  topicSelect = document.getElementById("topic-select"),
                  answerInput = document.getElementById("answer-input"),
                  summaryModal = document.getElementById("summary-modal"),
                  summaryDetails = document.getElementById("summary-details"),
                  apiKeyInput = document.getElementById("apiKey"),
                  voiceSelect = document.getElementById("voiceSelect"),
                  audioPlayer = document.getElementById("audioPlayer"),
                  newTopicInput = document.getElementById("new-topic-input"),
                  createTopicBtn = document.getElementById("create-topic-btn"),
                  questionTopicSelect = document.getElementById("question-topic-select"),
                  newQuestionInput = document.getElementById("new-question-input"),
                  createQuestionBtn = document.getElementById("create-question-btn"), 
                  voiceReplyBtn = document.getElementById('voice-reply-btn');
            
            // New Elements for Settings Panel
            const toggleSettingsBtn = document.getElementById('toggle-settings-btn'), 
                  settingsPanel = document.getElementById('settings-panel'), 
                  closeSettingsBtn = document.getElementById('close-settings-btn'), 
                  apiKeyInCallInput = document.getElementById('apiKey-in-call'), 
                  voiceSelectInCall = document.getElementById('voiceSelect-in-call');
            
            // DRAGGABLE ELEMENTS
            const userView = document.getElementById('user-view');
            const dragHandle = document.getElementById('drag-handle');
            const silenceIndicator = document.getElementById('silence-indicator');
            
            let currentUserId = '', currentSessionId = '', topics = [];
            const API_BASE_URL = 'https://f8abf4cdc39f.ngrok-free.app/v1';
            
            // --- DRAGGABLE FUNCTIONALITY ---
            let isDragging = false;
            let startX = 0, startY = 0;
            let currentTransformX = 0, currentTransformY = 0;
            
            function makeDraggable() {
                dragHandle.addEventListener('mousedown', startDrag);
                dragHandle.addEventListener('touchstart', startDrag, { passive: false });
                
                document.addEventListener('mousemove', doDrag);
                document.addEventListener('touchmove', doDrag, { passive: false });
                
                document.addEventListener('mouseup', stopDrag);
                document.addEventListener('touchend', stopDrag);
                
                // Prevent drag when clicking on textarea
                answerInput.addEventListener('mousedown', (e) => {
                    if (isDragging) {
                        e.stopPropagation();
                        stopDrag();
                    }
                });
                
                answerInput.addEventListener('touchstart', (e) => {
                    if (isDragging) {
                        e.stopPropagation();
                        stopDrag();
                    }
                });
            }
            
            function startDrag(e) {
                if (e.target !== dragHandle) return;
                
                e.preventDefault();
                isDragging = true;
                
                startX = e.type === 'mousedown' ? e.clientX : e.touches[0].clientX;
                startY = e.type === 'mousedown' ? e.clientY : e.touches[0].clientY;
                
                // Get current transform position
                const transform = userView.style.transform;
                if (transform) {
                    const match = transform.match(/translate\((-?\d+(\.\d+)?)px,\s*(-?\d+(\.\d+)?)px\)/);
                    if (match) {
                        currentTransformX = parseFloat(match[1]);
                        currentTransformY = parseFloat(match[3]);
                    }
                }
                
                userView.classList.add('dragging');
                document.body.style.userSelect = 'none';
                document.body.style.webkitUserSelect = 'none';
            }
            
            function doDrag(e) {
                if (!isDragging) return;
                
                e.preventDefault();
                
                const clientX = e.type === 'mousemove' ? e.clientX : e.touches[0].clientX;
                const clientY = e.type === 'mousemove' ? e.clientY : e.touches[0].clientY;
                
                const deltaX = clientX - startX;
                const deltaY = clientY - startY;
                
                const newX = currentTransformX + deltaX;
                const newY = currentTransformY + deltaY;
                
                // Constrain to viewport
                const maxX = window.innerWidth - userView.offsetWidth - 20;
                const maxY = window.innerHeight - userView.offsetHeight - 100;
                
                const constrainedX = Math.max(0, Math.min(maxX, newX));
                const constrainedY = Math.max(0, Math.min(maxY, newY));
                
                // Remove any existing positioning styles and use transform only
                userView.style.bottom = 'auto';
                userView.style.right = 'auto';
                userView.style.left = '0';
                userView.style.top = '0';
                userView.style.transform = `translate(${constrainedX}px, ${constrainedY}px)`;
            }
            
            function stopDrag() {
                if (!isDragging) return;
                
                isDragging = false;
                userView.classList.remove('dragging');
                document.body.style.userSelect = '';
                document.body.style.webkitUserSelect = '';
            }
            
            // --- VOICE RECOGNITION WITH SILENCE DETECTION ---
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            let recognition;
            let isRecognizing = false;
            let silenceTimer = null;
            let lastSpeechActivity = 0;
            let voiceBuffer = '';
            let isProcessingSpeech = false;
            const SILENCE_THRESHOLD = 4000; // 4 seconds
            
            if (SpeechRecognition) {
                recognition = new SpeechRecognition();
                recognition.continuous = true;
                recognition.interimResults = true;
                recognition.lang = 'en-US';
                
                recognition.onstart = () => { 
                    console.log('Voice recognition started');
                    isRecognizing = true; 
                    isProcessingSpeech = true;
                    voiceBuffer = '';
                    lastSpeechActivity = Date.now();
                    voiceReplyBtn.classList.add('is-recording'); 
                    voiceReplyBtn.title = 'Stop Recording';
                    silenceIndicator.classList.add('speaking');
                    silenceIndicator.classList.remove('silent');
                    startSilenceDetection();
                };
                
                recognition.onend = () => { 
                    console.log('Voice recognition ended');
                    isRecognizing = false; 
                    isProcessingSpeech = false;
                    voiceReplyBtn.classList.remove('is-recording'); 
                    voiceReplyBtn.title = 'Reply with Voice';
                    silenceIndicator.classList.remove('speaking');
                    silenceIndicator.classList.remove('silent');
                    stopSilenceDetection();
                };
                
                recognition.onerror = (event) => { 
                    console.error('Speech recognition error:', event.error); 
                    if (event.error === 'not-allowed') { 
                        alert('Microphone access was denied. Please allow it in your browser settings to use this feature.'); 
                    }
                    isRecognizing = false;
                    isProcessingSpeech = false;
                    silenceIndicator.classList.remove('speaking');
                    silenceIndicator.classList.remove('silent');
                    stopSilenceDetection();
                };

                recognition.onresult = (event) => {
                    let interimTranscript = '';
                    let finalTranscript = '';
                    
                    // Process all results from this event
                    for (let i = event.resultIndex; i < event.results.length; ++i) {
                        const transcript = event.results[i][0].transcript;
                        
                        if (event.results[i].isFinal) {
                            finalTranscript += transcript;
                        } else {
                            interimTranscript += transcript;
                        }
                    }
                    
                    // Update last activity time
                    if (finalTranscript || interimTranscript) {
                        lastSpeechActivity = Date.now();
                        silenceIndicator.classList.add('speaking');
                        silenceIndicator.classList.remove('silent');
                    }
                    
                    // Handle final results (commit to buffer)
                    if (finalTranscript) {
                        voiceBuffer += finalTranscript;
                        
                        // Check for voice commands in final results only
                        const commandFound = handleVoiceCommand(finalTranscript.toLowerCase().trim());
                        if (commandFound) {
                            // Remove command from buffer
                            voiceBuffer = voiceBuffer.replace(finalTranscript, '').trim();
                        }
                        
                        // Update the input field with the current buffer
                        updateAnswerInput();
                    }
                    
                    // Show interim results as they're coming in
                    if (interimTranscript) {
                        // For interim, just show preview in console for now
                        console.log('Interim:', interimTranscript);
                    }
                };
                
                function updateAnswerInput() {
                    const newText = voiceBuffer.trim();
                    
                    if (newText) {
                        // Simply replace with the current voice buffer to avoid duplicates
                        answerInput.value = newText;
                        answerInput.scrollTop = answerInput.scrollHeight;
                    }
                }
                
                function startSilenceDetection() {
                    // Clear any existing timer
                    if (silenceTimer) {
                        clearTimeout(silenceTimer);
                    }
                    
                    // Start monitoring for silence
                    const checkSilence = () => {
                        const silenceDuration = Date.now() - lastSpeechActivity;
                        
                        if (silenceDuration > SILENCE_THRESHOLD && isProcessingSpeech && voiceBuffer.trim()) {
                            console.log('Silence detected after', silenceDuration, 'ms - sending response');
                            silenceIndicator.classList.add('silent');
                            // Stop recognition first, then send answer
                            if (isRecognizing) {
                                recognition.stop();
                            }
                            // Use setTimeout to ensure recognition stops before sending
                            setTimeout(() => {
                                handleSendAnswer();
                            }, 100);
                            return;
                        }
                        
                        // Continue monitoring if still recognizing
                        if (isRecognizing) {
                            silenceTimer = setTimeout(checkSilence, 500);
                        }
                    };
                    
                    silenceTimer = setTimeout(checkSilence, 500);
                }
                
                function stopSilenceDetection() {
                    if (silenceTimer) {
                        clearTimeout(silenceTimer);
                        silenceTimer = null;
                    }
                    isProcessingSpeech = false;
                }
                
                voiceReplyBtn.addEventListener('click', () => {
                    if (isRecognizing) { 
                        console.log('Stopping voice recognition');
                        recognition.stop();
                    } else {
                        console.log('Starting voice recognition');
                        // Reset state
                        stopSilenceDetection();
                        voiceBuffer = '';
                        lastSpeechActivity = Date.now();
                        answerInput.value = answerInput.value.replace(/<voice>.*?<\/voice>/, '').trim();
                        
                        // Start recognition
                        try {
                            recognition.start();
                        } catch (error) {
                            console.error('Failed to start recognition:', error);
                        }
                    }
                });
            } else {
                console.warn("Speech Recognition not supported in this browser.");
                voiceReplyBtn.style.display = 'none';
            }

            // --- Voice Command Handler ---
            function handleVoiceCommand(transcript) {
                const commands = {
                    "send answer": () => { 
                        console.log("Voice command: Send Answer"); 
                        handleSendAnswer(); 
                        return true; 
                    },
                    "submit answer": () => { 
                        console.log("Voice command: Submit Answer"); 
                        handleSendAnswer(); 
                        return true; 
                    },
                    "stop listening": () => { 
                        console.log("Voice command: Stop Listening"); 
                        if (isRecognizing) recognition.stop(); 
                        return true; 
                    },
                    "open chat": () => { 
                        console.log("Voice command: Open Chat"); 
                        meetScreen.classList.remove('settings-open'); 
                        meetScreen.classList.add('chat-open'); 
                        return true; 
                    },
                    "close chat": () => { 
                        console.log("Voice command: Close Chat"); 
                        meetScreen.classList.remove('chat-open'); 
                        return true; 
                    },
                    "open settings": () => { 
                        console.log("Voice command: Open Settings"); 
                        meetScreen.classList.remove('chat-open'); 
                        meetScreen.classList.add('settings-open'); 
                        return true; 
                    },
                    "close settings": () => { 
                        console.log("Voice command: Close Settings"); 
                        meetScreen.classList.remove('settings-open'); 
                        return true; 
                    },
                    "end interview": () => { 
                        console.log("Voice command: End Interview"); 
                        handleEndInterview(); 
                        return true; 
                    },
                    "hang up": () => { 
                        console.log("Voice command: Hang Up"); 
                        handleEndInterview(); 
                        return true; 
                    }
                };
                
                for (const phrase in commands) { 
                    if (transcript.toLowerCase().includes(phrase)) { 
                        commands[phrase]();
                        return true;
                    } 
                }
                return false; 
            }

            const updateTime = () => { 
                currentTimeEl.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }); 
            };
            setInterval(updateTime, 60000); 
            updateTime();
            
            // Test API connection on page load
            testApiConnection();
            
            // Event Listeners
            joinBtn.addEventListener('click', handleStartInterview);
            hangUpBtn.addEventListener('click', handleEndInterview);
            closeSummaryBtn.addEventListener('click', () => { 
                summaryModal.classList.add('hidden'); 
                meetScreen.classList.add('hidden'); 
                lobbyScreen.classList.remove('hidden'); 
            });
            sendAnswerBtn.addEventListener('click', handleSendAnswer);
            answerInput.addEventListener('keydown', (e) => { 
                if (e.key === 'Enter' && !e.shiftKey) { 
                    e.preventDefault(); 
                    handleSendAnswer(); 
                } 
            });
            
            toggleChatBtn.addEventListener('click', () => { 
                meetScreen.classList.remove('settings-open'); 
                meetScreen.classList.toggle('chat-open'); 
            });
            closeChatBtn.addEventListener('click', () => { 
                meetScreen.classList.remove('chat-open'); 
            }); 
            
            toggleSettingsBtn.addEventListener('click', () => { 
                meetScreen.classList.remove('chat-open'); 
                meetScreen.classList.toggle('settings-open'); 
            });
            closeSettingsBtn.addEventListener('click', () => { 
                meetScreen.classList.remove('settings-open'); 
            }); 

            // Sync settings between lobby and in-call panel
            apiKeyInput.addEventListener('input', () => apiKeyInCallInput.value = apiKeyInput.value);
            voiceSelect.addEventListener('change', () => voiceSelectInCall.value = voiceSelect.value);
            apiKeyInCallInput.addEventListener('input', () => apiKeyInput.value = apiKeyInCallInput.value);
            voiceSelectInCall.addEventListener('change', () => voiceSelect.value = voiceSelectInCall.value);

            // Tab functionality
            const tabButtons = document.querySelectorAll(".tab-button"), tabPanes = document.querySelectorAll(".tab-pane");
            tabButtons.forEach(button => {
                button.addEventListener("click", () => {
                    tabButtons.forEach(btn => btn.classList.remove("active"));
                    button.classList.add("active");
                    const targetPaneId = button.dataset.tab;
                    tabPanes.forEach(pane => {
                        pane.classList.toggle("hidden", pane.id !== targetPaneId)
                    });
                });
            });
            
            // Initialize draggable functionality
            makeDraggable();
            
            async function speakText(text) {
                const apiKey = apiKeyInCallInput.value.trim();
                if (!apiKey || !text) return;
                const requestBody = { 
                    input: { text }, 
                    voice: { 
                        languageCode: voiceSelectInCall.value.substring(0, 5), 
                        name: voiceSelectInCall.value 
                    }, 
                    audioConfig: { audioEncoding: 'MP3' } 
                };
                const apiUrl = `https://texttospeech.googleapis.com/v1/text:synthesize?key=${apiKey}`;
                try {
                    const response = await fetch(apiUrl, { 
                        method: 'POST', 
                        headers: { 'Content-Type': 'application/json' }, 
                        body: JSON.stringify(requestBody) 
                    });
                    if (!response.ok) throw new Error('TTS API error');
                    const data = await response.json();
                    if (data.audioContent) { 
                        audioPlayer.src = `data:audio/mp3;base64,${data.audioContent}`; 
                        audioPlayer.play(); 
                    }
                } catch (error) { 
                    console.error('TTS Failed:', error); 
                }
            }

            async function apiCall(endpoint, method = 'GET', body = null, extraHeaders = {}) {
                const headers = { 
                    'Content-Type': 'application/json', 
                    'X-User-ID': currentUserId, 
                    'ngrok-skip-browser-warning': 'true',
                    ...extraHeaders 
                };
                const config = { method, headers };
                if (body) config.body = JSON.stringify(body);
                try {
                    const response = await fetch(`${API_BASE_URL}${endpoint}`, config);
                    if (response.status === 204) return null;
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ message: 'API error' }));
                        throw new Error(errorData.message || `HTTP ${response.status}`);
                    }
                    return await response.json();
                } catch (error) { 
                    console.error('API Call Failed:', error); 
                    if (error.message.includes('Failed to fetch')) {
                        throw new Error('Network error - check if backend is running and accessible');
                    }
                    throw error; 
                }
            }
            
            function addMessageToChatHistory(sender, text) { 
                const senderEl = document.createElement('div'); 
                senderEl.className = 'sender'; 
                senderEl.textContent = sender; 
                const textEl = document.createElement('div'); 
                textEl.textContent = text; 
                const messageContainer = document.createElement('div'); 
                messageContainer.className = 'chat-message'; 
                messageContainer.append(senderEl, textEl); 
                chatHistory.appendChild(messageContainer); 
                chatHistory.scrollTop = chatHistory.scrollHeight; 
            }
            
            function resetUI() { 
                chatHistory.innerHTML = ''; 
                answerInput.value = ''; 
                voiceBuffer = '';
                currentSessionId = ''; 
                interviewerMessage.textContent = 'Waiting to start...'; 
                meetScreen.classList.remove('chat-open'); 
                meetScreen.classList.remove('settings-open'); 
                
                // Reset user view position
                userView.style.transform = '';
                userView.style.bottom = '110px';
                userView.style.right = '20px';
                userView.style.left = 'auto';
                userView.style.top = 'auto';
                currentTransformX = 0;
                currentTransformY = 0;
            }

            async function testApiConnection() {
                try {
                    console.log('Testing API connection...');
                    const response = await fetch(`https://f8abf4cdc39f.ngrok-free.app/health`, {
                        headers: { 'ngrok-skip-browser-warning': 'true' }
                    });
                    if (response.ok) {
                        console.log('API connection successful');
                        if (topicSelect.innerHTML.includes('Loading topics')) {
                            topicSelect.innerHTML = '<option value="">Select a topic...</option>';
                        }
                        return true;
                    } else {
                        console.error('API connection failed:', response.status);
                        topicSelect.innerHTML = '<option value="">API connection failed</option>';
                        return false;
                    }
                } catch (error) {
                    console.error('API connection error:', error);
                    topicSelect.innerHTML = '<option value="">Network error - check backend</option>';
                    return false;
                }
            }

            function populateVoiceSelectors() {
                const voiceOptions = `
                    <optgroup label="English (US)">
                        <option value="en-US-Standard-B" selected>US Male (Standard)</option>
                        <option value="en-US-Standard-C">US Female (Standard)</option>
                    </optgroup>
                    <optgroup label="English (UK)">
                        <option value="en-GB-Standard-B">UK Male (Standard)</option>
                        <option value="en-GB-Standard-C">UK Female (Standard)</option>
                    </optgroup>
                    <optgroup label="English (Australia)">
                        <option value="en-AU-Standard-B">AU Male (Standard)</option>
                        <option value="en-AU-Standard-C">AU Female (Standard)</option>
                    </optgroup>
                     <optgroup label="English (India)">
                        <option value="en-IN-Standard-B">Indian Male (Standard)</option>
                        <option value="en-IN-Standard-A">Indian Female (Standard)</option>
                    </optgroup>`;
                voiceSelect.innerHTML = voiceOptions;
                voiceSelectInCall.innerHTML = voiceOptions;
            }
            populateVoiceSelectors();

            async function fetchAndPopulateTopics() {
                currentUserId = userIdInput.value.trim();
                if (!currentUserId) { 
                    topicSelect.innerHTML = '<option value="">Set User ID first</option>'; 
                    return; 
                }
                try {
                    topics = await apiCall('/topics');
                    if (topics && topics.length > 0) { 
                        const options = topics.map(t => `<option value="${t.ID}">${t.Topic}</option>`).join('');
                        topicSelect.innerHTML = options;
                        questionTopicSelect.innerHTML = options;
                    } else { 
                        const msg = '<option value="">No topics found</option>';
                        topicSelect.innerHTML = msg;
                        questionTopicSelect.innerHTML = msg;
                    }
                } catch (e) { 
                    topicSelect.innerHTML = '<option>Error loading topics</option>'; 
                }
            }

            async function handleStartInterview() {
                currentUserId = userIdInput.value.trim();
                if (!currentUserId || !topicSelect.value) { 
                    alert('Please set a User ID and select a topic.'); 
                    return; 
                }
                
                // Sync settings to in-call panel before starting
                apiKeyInCallInput.value = apiKeyInput.value;
                voiceSelectInCall.value = voiceSelect.value;

                lobbyScreen.classList.add('hidden');
                meetScreen.classList.remove('hidden');
                resetUI();
                
                try {
                    const sessionData = await apiCall('/interview/start', 'POST', null, { 'X-Topic-ID': topicSelect.value });
                    currentSessionId = sessionData.session_id;
                    interviewerMessage.textContent = sessionData.initial_question;
                    addMessageToChatHistory('AI Interviewer', sessionData.initial_question);
                    speakText(sessionData.initial_question);
                } catch (error) { 
                    interviewerMessage.textContent = `Error: ${error.message}`; 
                }
            }
            
            async function handleEndInterview() {
                if(isRecognizing) {
                    recognition.stop();
                }
                if (!currentSessionId) { 
                    meetScreen.classList.add('hidden'); 
                    lobbyScreen.classList.remove('hidden'); 
                    return; 
                }
                try {
                    const data = await apiCall(`/interview/end/${currentSessionId}`, 'POST');
                    displaySummary(data.summary);
                    summaryModal.classList.remove('hidden');
                } catch (error) { 
                    alert(`Error ending session: ${error.message}`); 
                }
            }
            
            async function handleSendAnswer() {
                console.log('handleSendAnswer called');
                if (isRecognizing) {
                    recognition.stop();
                }
                
                const text = (voiceBuffer || answerInput.value).trim();
                console.log('Sending text:', text);
                
                if (!text || !currentSessionId) {
                    console.log('No text or no session, aborting');
                    return;
                }
                
                // Clear everything
                answerInput.value = '';
                voiceBuffer = '';
                
                addMessageToChatHistory('You', text);
                
                try {
                    const data = await apiCall(`/interview/${currentSessionId}`, 'POST', { text });
                    console.log('API response:', data);
                    if(data && data.response) {
                        interviewerMessage.textContent = data.response;
                        addMessageToChatHistory('AI Interviewer', data.response);
                        speakText(data.response);
                        
                        if (data.session_ended) {
                            setTimeout(() => {
                                displaySummary(data.summary);
                                summaryModal.classList.remove('hidden');
                            }, 2000);
                        }
                    }
                } catch (error) { 
                    console.error('Send answer error:', error);
                    interviewerMessage.textContent = `Error: ${error.message}`; 
                }
            }
            
            async function handleCreateTopic() {
                currentUserId = userIdInput.value.trim();
                const topicName = newTopicInput.value.trim();
                if (!currentUserId || !topicName) { 
                    alert('Set User ID and enter a topic name.'); 
                    return; 
                }
                try { 
                    await apiCall('/topics', 'POST', { topic: topicName }); 
                    newTopicInput.value = ''; 
                    alert('Topic created!'); 
                    fetchAndPopulateTopics(); 
                }
                catch (e) { 
                    alert(`Error: ${e.message}`); 
                }
            }
            
            async function handleCreateQuestion() {
                 currentUserId = userIdInput.value.trim();
                 const topicId = questionTopicSelect.value;
                 const questionText = newQuestionInput.value.trim();
                 if (!currentUserId || !topicId || !questionText) { 
                     alert('Please select a topic and enter question text.'); 
                     return; 
                 }
                 try {
                     await apiCall('/questions', 'POST', { topic_id: topicId, question: questionText });
                     newQuestionInput.value = '';
                     alert('Question created successfully!');
                 } catch(e) { 
                     alert(`Error creating question: ${e.message}`); 
                 }
            }

            function displaySummary(summary) {
                if (!summary) { 
                    summaryDetails.innerHTML = "<p>Could not retrieve summary.</p>"; 
                    return; 
                }
                const listify = (items) => items && items.length > 0 ? `<ul style="list-style-position: inside; padding-left: 10px;">${items.map(item => `<li>${item}</li>`).join('')}</ul>` : '<p>None noted.</p>';
                summaryDetails.innerHTML = `
                    <h4 style="margin-top:0;">Interview Scores</h4>
                    <div style="display: flex; gap: 20px; margin-bottom: 20px;">
                        <div style="background: #3c4043; padding: 15px; border-radius: 8px; flex: 1;">
                            <h5 style="margin: 0 0 5px 0; color: #8ab4f8;">Technical Score</h5>
                            <div style="font-size: 24px; font-weight: bold;">${summary.technical_score}/100</div>
                        </div>
                        <div style="background: #3c4043; padding: 15px; border-radius: 8px; flex: 1;">
                            <h5 style="margin: 0 0 5px 0; color: #8ab4f8;">Grammar Score</h5>
                            <div style="font-size: 24px; font-weight: bold;">${summary.grammatical_score}/100</div>
                        </div>
                    </div>
                    <h4>Strong Points</h4>
                    ${listify(summary.strong_points)}
                    <h4>Areas for Improvement</h4>
                    ${listify(summary.weak_points)}
                    <h4>Practice Recommendations</h4>
                    ${listify(summary.practice_points)}
                    <div style="margin-top: 15px; padding: 10px; background: #2d2f34; border-radius: 6px; font-size: 14px;">
                        <strong>Interview Stats:</strong> 
                        ${summary.contextual_relevant ? 'Responses were relevant' : 'Some responses were off-topic'} 
                        ${summary.off_topic_count > 0 ? `(${summary.off_topic_count} off-topic responses)` : ''}
                    </div>
                `;
            }
            
            // Event listeners for management
            userIdInput.addEventListener('change', fetchAndPopulateTopics);
            createTopicBtn.addEventListener('click', handleCreateTopic);
            createQuestionBtn.addEventListener('click', handleCreateQuestion);
        });
    </script>
</body>
</html>